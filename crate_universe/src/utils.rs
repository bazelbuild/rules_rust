//! Common utilities

pub(crate) mod starlark;
pub(crate) mod target_triple;

pub(crate) const CRATES_IO_INDEX_URL: &str = "https://github.com/rust-lang/crates.io-index";

use std::collections::{BTreeMap, BTreeSet};
use std::path::{Path, PathBuf};

/// Convert a string into a valid crate module name by applying transforms to invalid characters
pub(crate) fn sanitize_module_name(name: &str) -> String {
    name.replace('-', "_")
}

/// Some character which may be present in version IDs are not valid
/// in Bazel repository names. This converts invalid characters. See
/// [RepositoryName.java](https://github.com/bazelbuild/bazel/blob/4.0.0/src/main/java/com/google/devtools/build/lib/cmdline/RepositoryName.java#L42)
pub(crate) fn sanitize_repository_name(name: &str) -> String {
    name.replace('+', "-")
}

/// We need to sanitize the cargo vendor'ed folder names.  Cargo automatically vendors the crates
/// based off the semver spec (libfoo-v.1.1.0+MyMeta), thus making bazel labels invalid, since they
/// dont accept a (+) symbol.  This simpley takes the outputs, and will sanitize the path bufs for
/// buildifier and for when we write the outputs.
pub(crate) fn sanitize_vendor_file_names(outputs: &BTreeMap<PathBuf, String>) -> BTreeSet<PathBuf> {
    outputs
        .keys()
        .cloned()
        .map(|p| {
            let p_str = sanitize_repository_name(p.to_str().unwrap());
            PathBuf::from(p_str)
        })
        .collect()
}

/// Vendored crates are generated by cargo itself in `src/metadata.rs` in the
/// `VendorGenerator::generate()` method.  This means that the semver metadata will
/// always contain a (+) symbol, which is not compatible with bazel's labels.  
/// This function will rename the cargo vendor generated file paths to be compatible with bazel
/// labels by simply replacing the (+) with a (-). If this file is called by any other cli mod,
/// it just simply joins the out dir to the path
pub(crate) fn normalize_cargo_file_paths(
    outputs: BTreeMap<PathBuf, String>,
    out_dir: &Path,
) -> BTreeMap<PathBuf, String> {
    outputs
        .into_iter()
        .map(|(path, content)| {
            let path = out_dir.join(path);
            let original_path_str = path
                .parent()
                .expect("All file paths should have valid directories")
                .to_str()
                .expect("All file paths should be strings");
            let new_path = if original_path_str.contains('+') {
                let new_file_path = sanitize_repository_name(original_path_str);
                std::fs::rename(original_path_str, &new_file_path).expect("Could not rename file");
                PathBuf::from(new_file_path)
            } else {
                path
            };

            (new_path, content)
        })
        .collect()
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_sanitize_vendor_file_names() {
        let mut outputs = BTreeMap::new();
        outputs.insert(
            PathBuf::from("/path/to/libbpf-sys-1.3.0+v1.3.0"),
            "test".into(),
        );

        let got = sanitize_vendor_file_names(&outputs);
        for value in got {
            assert_eq!(value, PathBuf::from("/path/to/libbpf-sys-1.3.0-v1.3.0"))
        }
    }

    #[test]
    fn test_sanitize_vendor_file_names_no_change() {
        let mut outputs = BTreeMap::new();
        outputs.insert(PathBuf::from("/path/to/tokio-1.20.0"), "test".into());

        let got = sanitize_vendor_file_names(&outputs);
        for value in got {
            assert_eq!(value, PathBuf::from("/path/to/tokio-1.20.0"))
        }
    }

    #[test]
    fn test_sanitize_repository_name() {
        let name = "anyhow-1.0.0+semver_meta";
        let got = sanitize_repository_name(name);
        assert_eq!(got, String::from("anyhow-1.0.0-semver_meta"));
    }

    #[test]
    fn test_sanitize_repository_name_no_change() {
        let name = "tokio-1.20.0";
        let got = sanitize_repository_name(name);
        assert_eq!(got, String::from("tokio-1.20.0"));
    }
}
