//! The cli entrypoint for the `generate` subcommand

use std::fs;
use std::path::PathBuf;

use anyhow::{bail, Context as AnyhowContext, Result};
use clap::Parser;

use crate::config::Config;
use crate::context::Context;
use crate::lockfile::{lock_context, write_lockfile};
use crate::metadata::load_metadata;
use crate::metadata::Annotations;
use crate::rendering::{write_outputs, Renderer};
use crate::splicing::SplicingManifest;

/// Command line options for the `generate` subcommand
#[derive(Parser, Debug)]
#[clap(about = "Command line options for the `generate` subcommand", version)]
pub struct GenerateOptions {
    /// The path to a Cargo binary to use for gathering metadata
    #[clap(long, env = "CARGO")]
    pub cargo: Option<PathBuf>,

    /// The path to a rustc binary for use with Cargo
    #[clap(long, env = "RUSTC")]
    pub rustc: Option<PathBuf>,

    /// The config file with information about the Bazel and Cargo workspace
    #[clap(long)]
    pub config: PathBuf,

    /// A generated manifest of splicing inputs
    #[clap(long)]
    pub splicing_manifest: PathBuf,

    /// The path to either a Cargo or Bazel lockfile
    #[clap(long)]
    pub lockfile: Option<PathBuf>,

    /// The path to a [Cargo.lock](https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html) file.
    #[clap(long)]
    pub cargo_lockfile: PathBuf,

    /// The directory of the current repository rule
    #[clap(long)]
    pub repository_dir: PathBuf,

    /// A [Cargo config](https://doc.rust-lang.org/cargo/reference/config.html#configuration)
    /// file to use when gathering metadata
    #[clap(long)]
    pub cargo_config: Option<PathBuf>,

    /// Whether or not to ignore the provided lockfile and re-generate one
    #[clap(long)]
    pub repin: bool,

    /// The path to a Cargo metadata `json` file. This file must be next to a `Cargo.toml` and `Cargo.lock` file.
    #[clap(long)]
    pub metadata: Option<PathBuf>,

    /// If true, outputs will be printed instead of written to disk.
    #[clap(long)]
    pub dry_run: bool,
}

pub fn generate(opt: GenerateOptions) -> Result<()> {
    // Load the config
    let config = Config::try_from_path(&opt.config)
        .with_context(|| format!("Failed to parse config from {}", opt.config.display()))?;

    // Go straight to rendering if there is no need to repin
    if !opt.repin {
        if let Some(lockfile) = &opt.lockfile {
            let context = Context::try_from_path(lockfile)?;

            // Render build files
            let outputs = Renderer::new(config.rendering).render(&context)?;

            // Write the outputs to disk
            write_outputs(outputs, &opt.repository_dir, opt.dry_run)?;

            return Ok(());
        }
    }

    // Ensure Cargo and Rustc are available for use during generation.
    let cargo_bin = match &opt.cargo {
        Some(bin) => bin,
        None => bail!("The `--cargo` argument is required when generating unpinned content"),
    };
    let rustc_bin = match &opt.rustc {
        Some(bin) => bin,
        None => bail!("The `--rustc` argument is required when generating unpinned content"),
    };

    // Ensure a path to a metadata file was provided
    let metadata_path = match &opt.metadata {
        Some(path) => path,
        None => bail!("The `--metadata` argument is required when generating unpinned content"),
    };

    // Load Metadata and Lockfile
    let (cargo_metadata, cargo_lockfile) = load_metadata(metadata_path)?;

    // Copy the rendering config for later use
    let render_config = config.rendering.clone();

    // Annotate metadata
    let annotations = Annotations::new(
        cargo_metadata,
        cargo_lockfile.parsed.clone(),
        config.clone(),
    )?;

    // Generate renderable contexts for earch package
    let context = Context::new(annotations)?;

    // Render build files
    let outputs = Renderer::new(render_config).render(&context)?;

    // Write outputs
    write_outputs(outputs, &opt.repository_dir, opt.dry_run)?;

    // Ensure Bazel lockfiles are written to disk so future generations can be short-circuted.
    if let Some(lockfile) = opt.lockfile {
        let splicing_manifest = SplicingManifest::try_from_path(&opt.splicing_manifest)?;

        let lock_content =
            lock_context(context, &config, &splicing_manifest, cargo_bin, rustc_bin)?;

        write_lockfile(lock_content, &lockfile, opt.dry_run)?;
    }

    // Write the updated Cargo.lock file
    // We write the content as generated by cargo, not as serialized by cargo_lockfile, to avoid spurious diffs from formatting discrepancies.
    fs::write(&opt.cargo_lockfile, cargo_lockfile.content)
        .context("Failed to write Cargo.lock file back to the workspace.")?;

    Ok(())
}

#[cfg(test)]
mod test {
    use crate::config::Config;
    use pretty_assertions::assert_eq;
    use std::fs::File;
    use std::io::Write;
    use std::path::{Path, PathBuf};

    // Regression test for https://github.com/bazelbuild/rules_rust/issues/1535
    // Previously, we were serializing output from cargo-lockfile which was not formatted
    // identically to what cargo outputs, so any time people repinned via cargo-bazel
    // they would get spurious diffs to their Cargo.lock files.
    // Both files would work, but the difference was noisy.
    // Ensure we don't regress here.
    #[test]
    fn repin_roundtrip() {
        let metadata_dir = tempfile::tempdir().unwrap();

        let cargo_lock_file_path = metadata_dir.path().join("Cargo.lock");
        write_file(&cargo_lock_file_path, CARGO_LOCK_FILE_CONTENT);

        let cargo_metadata_file_path = metadata_dir.path().join("metadata.json");
        write_file(&cargo_metadata_file_path, CARGO_METADATA_OUTPUT);

        let config_temp_file = tempfile::NamedTempFile::new().unwrap();
        let config = Config {
            rendering: serde_json::from_str(
                r#"{
          "repository_name": "blah",
          "regen_command": ""
        }"#,
            )
            .unwrap(),
            ..Config::default()
        };
        write_file(
            config_temp_file.path(),
            &serde_json::to_string(&config).unwrap(),
        );

        let splicing_manifest = tempfile::NamedTempFile::new().unwrap();

        let repository_dir = tempfile::tempdir().unwrap();

        super::generate(super::GenerateOptions {
            cargo: std::env::var_os("CARGO").map(PathBuf::from),
            rustc: std::env::var_os("RUSTC").map(PathBuf::from),
            config: config_temp_file.path().to_owned(),
            splicing_manifest: splicing_manifest.path().to_owned(),
            lockfile: None,
            cargo_lockfile: cargo_lock_file_path.clone(),
            repository_dir: repository_dir.path().to_owned(),
            cargo_config: None,
            repin: true,
            metadata: Some(cargo_metadata_file_path),
            dry_run: false,
        })
        .unwrap();

        let modified_lockfile = std::fs::read_to_string(cargo_lock_file_path).unwrap();

        assert_eq!(CARGO_LOCK_FILE_CONTENT, modified_lockfile);
    }

    fn write_file(to: &Path, content: &str) {
        let mut file = File::create(to).unwrap();
        write!(file, "{}", content).unwrap();
    }

    // Generated from this Cargo.toml:
    // [package]
    // name = "example"
    // version = "0.1.0"
    // edition = "2021"
    //
    // [dependencies]
    // bytes = "=0.6.0"
    // bytestring = "=1.1.0"
    //
    // [lib]
    // path = "src/lib.rs"

    const CARGO_LOCK_FILE_CONTENT: &str = r#"# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3

[[package]]
name = "bytes"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0dcbc35f504eb6fc275a6d20e4ebcda18cf50d40ba6fabff8c711fa16cb3b16"

[[package]]
name = "bytes"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec8a7b6a70fde80372154c65702f00a0f56f3e1c36abbc6c440484be248856db"

[[package]]
name = "bytestring"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b6a75fd3048808ef06af5cd79712be8111960adaf89d90250974b38fc3928a"
dependencies = [
 "bytes 1.2.1",
]

[[package]]
name = "example"
version = "0.1.0"
dependencies = [
 "bytes 0.6.0",
 "bytestring",
]
"#;

    const CARGO_METADATA_OUTPUT: &str = r#"{"packages":[{"name":"bytes","version":"0.6.0","id":"bytes 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)","license":"MIT","license_file":null,"description":"Types and traits for working with bytes","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.60","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"serde_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.3","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(loom)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_buf","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_buf.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes_odd_alloc","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_bytes_odd_alloc.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_bytes.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_debug","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_debug.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_iter","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_iter.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_reader","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_reader.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes_vec_alloc","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_bytes_vec_alloc.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_chain","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_chain.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_serde","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_serde.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_buf_mut","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_buf_mut.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_take","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/tests/test_take.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"buf","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/benches/buf.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"bytes_mut","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/benches/bytes_mut.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/benches/bytes.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"serde":["dep:serde"],"std":[]},"manifest_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-0.6.0/Cargo.toml","metadata":null,"publish":null,"authors":["Carl Lerche <me@carllerche.com>","Sean McArthur <sean@seanmonstar.com>"],"categories":["network-programming","data-structures"],"keywords":["buffers","zero-copy","io"],"readme":"README.md","repository":"https://github.com/tokio-rs/bytes","homepage":null,"documentation":"https://docs.rs/bytes/0.6.0/bytes/","edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"bytes","version":"1.2.1","id":"bytes 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)","license":"MIT","license_file":null,"description":"Types and traits for working with bytes","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0.60","kind":null,"rename":null,"optional":true,"uses_default_features":false,"features":["alloc"],"target":null,"registry":null},{"name":"serde_test","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"loom","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^0.5","kind":"dev","rename":null,"optional":false,"uses_default_features":true,"features":[],"target":"cfg(loom)","registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_buf","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_buf.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes_odd_alloc","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_bytes_odd_alloc.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_bytes.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_debug","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_debug.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_iter","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_iter.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_reader","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_reader.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_bytes_vec_alloc","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_bytes_vec_alloc.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_chain","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_chain.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_serde","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_serde.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_buf_mut","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_buf_mut.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["test"],"crate_types":["bin"],"name":"test_take","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/tests/test_take.rs","edition":"2018","doc":false,"doctest":false,"test":true},{"kind":["bench"],"crate_types":["bin"],"name":"buf","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/benches/buf.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"bytes_mut","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/benches/bytes_mut.rs","edition":"2018","doc":false,"doctest":false,"test":false},{"kind":["bench"],"crate_types":["bin"],"name":"bytes","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/benches/bytes.rs","edition":"2018","doc":false,"doctest":false,"test":false}],"features":{"default":["std"],"serde":["dep:serde"],"std":[]},"manifest_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytes-1.2.1/Cargo.toml","metadata":{"docs":{"rs":{"rustdoc-args":["--cfg","docsrs"]}}},"publish":null,"authors":["Carl Lerche <me@carllerche.com>","Sean McArthur <sean@seanmonstar.com>"],"categories":["network-programming","data-structures"],"keywords":["buffers","zero-copy","io"],"readme":"README.md","repository":"https://github.com/tokio-rs/bytes","homepage":null,"documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"bytestring","version":"1.1.0","id":"bytestring 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)","license":"MIT OR Apache-2.0","license_file":null,"description":"An immutable UTF-8 encoded string using Bytes as storage","source":"registry+https://github.com/rust-lang/crates.io-index","dependencies":[{"name":"bytes","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"serde","source":"registry+https://github.com/rust-lang/crates.io-index","req":"^1.0","kind":null,"rename":null,"optional":true,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"bytestring","src_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytestring-1.1.0/src/lib.rs","edition":"2018","doc":true,"doctest":true,"test":true}],"features":{"serde":["dep:serde"]},"manifest_path":"/cargo_home/registry/src/github.com-1ecc6299db9ec823/bytestring-1.1.0/Cargo.toml","metadata":null,"publish":null,"authors":["Nikolay Kim <fafhrd91@gmail.com>","Rob Ede <robjtede@icloud.com>"],"categories":["no-std","web-programming"],"keywords":["string","bytes","utf8","web","actix"],"readme":null,"repository":"https://github.com/actix/actix-net.git","homepage":"https://actix.rs","documentation":null,"edition":"2018","links":null,"default_run":null,"rust_version":null},{"name":"example","version":"0.1.0","id":"example 0.1.0 (path+file:///ws)","license":null,"license_file":null,"description":null,"source":null,"dependencies":[{"name":"bytes","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=0.6.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null},{"name":"bytestring","source":"registry+https://github.com/rust-lang/crates.io-index","req":"=1.1.0","kind":null,"rename":null,"optional":false,"uses_default_features":true,"features":[],"target":null,"registry":null}],"targets":[{"kind":["lib"],"crate_types":["lib"],"name":"example","src_path":"/ws/src/lib.rs","edition":"2021","doc":true,"doctest":true,"test":true}],"features":{},"manifest_path":"/ws/Cargo.toml","metadata":null,"publish":null,"authors":[],"categories":[],"keywords":[],"readme":null,"repository":null,"homepage":null,"documentation":null,"edition":"2021","links":null,"default_run":null,"rust_version":null}],"workspace_members":["example 0.1.0 (path+file:///ws)"],"resolve":{"nodes":[{"id":"bytes 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)","dependencies":[],"deps":[],"features":["default","std"]},{"id":"bytes 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)","dependencies":[],"deps":[],"features":["default","std"]},{"id":"bytestring 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)","dependencies":["bytes 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)"],"deps":[{"name":"bytes","pkg":"bytes 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)","dep_kinds":[{"kind":null,"target":null}]}],"features":[]},{"id":"example 0.1.0 (path+file:///ws)","dependencies":["bytes 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)","bytestring 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)"],"deps":[{"name":"bytes","pkg":"bytes 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)","dep_kinds":[{"kind":null,"target":null}]},{"name":"bytestring","pkg":"bytestring 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)","dep_kinds":[{"kind":null,"target":null}]}],"features":[]}],"root":"example 0.1.0 (path+file:///ws)"},"target_directory":"/ws/target","version":1,"workspace_root":"/ws","metadata":null}"#;
}
