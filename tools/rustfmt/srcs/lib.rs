use std::env;
use std::fs;
use std::path::{Path, PathBuf};

/// The expected extension of rustfmt manifest files generated by `rustfmt_aspect`.
pub const RUSTFMT_MANIFEST_EXTENSION: &str = "rustfmt";

pub fn current_dir_name() -> PathBuf {
    PathBuf::from(std::env::current_dir().unwrap().file_name().unwrap())
}

pub fn from_slash(p: PathBuf) -> PathBuf {
    let s = p
        .to_string_lossy()
        .chars()
        .map(|c| match c {
            '/' => std::path::MAIN_SEPARATOR,
            c => c,
        })
        .collect::<String>();
    PathBuf::from(s)
}

/// A struct containing details used for executing rustfmt.
#[derive(Debug)]
pub struct RustfmtConfig {
    /// The rustfmt binary from the currently active toolchain
    pub rustfmt: PathBuf,

    /// The rustfmt config file containing rustfmt settings.
    /// https://rust-lang.github.io/rustfmt/
    pub config: PathBuf,
}

/// Parse command line arguments and environment variables to
/// produce config data for running rustfmt.
pub fn parse_rustfmt_config() -> RustfmtConfig {
    let runfiles = runfiles::Runfiles::create().expect("Failed to find runfiles");

    RustfmtConfig {
        rustfmt: runfiles.rlocation(current_dir_name().join(&env!("RUSTFMT"))),
        config: runfiles.rlocation(current_dir_name().join(&env!("RUSTFMT_CONFIG"))),
    }
}

/// A struct of target specific information for use in running `rustfmt`.
#[derive(Debug)]
pub struct RustfmtManifest {
    /// The Rust edition of the Bazel target
    pub edition: String,

    /// A list of all (non-generated) source files for formatting.
    pub sources: Vec<String>,
}

/// Parse rustfmt flags from a manifest generated by builds using `rustfmt_aspect`.
pub fn parse_rustfmt_manifest(manifest: &Path) -> RustfmtManifest {
    let content = fs::read_to_string(manifest)
        .unwrap_or_else(|_| panic!("Failed to read rustfmt manifest: {}", manifest.display()));

    let mut lines: Vec<String> = content
        .split('\n')
        .into_iter()
        .filter(|s| !s.is_empty())
        .map(|s| s.to_owned())
        .collect();

    let edition = lines
        .pop()
        .expect("There should always be at least 1 line in the manifest");
    edition
        .parse::<i32>()
        .expect("The edition should be a numeric value. eg `2018`.");

    RustfmtManifest {
        edition,
        sources: lines,
    }
}
